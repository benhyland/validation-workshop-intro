<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">

		<title>Validation Workshop</title>

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/simple.css">
		<link rel="stylesheet" href="css/prism.css">
	</head>

	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h1>Validation Workshop</h1>
				</section>
				<section>
					<h2>Why are we here?</h2>
					<p>
						<ul>
							<li>practice our skills with higher-order functions in Ruby</li>
							<li>improve our ability to recognise common functional patterns</li>
							<li>implement a functional pattern as an exercise</li>
						</ul>
					</p>
				</section>
				<section>
					<h2>What is functional programming?</h2>
					<p>
						As a definition:
						<ul>
							<li>programming with functions</li>
							<li>referential transparency/equational reasoning</li>
						</ul>
					</p>
				</section>
				<section>
					<h2>What is functional programming?</h2>
					<p>
						What do we mean to do in our system? Stuff like:
						<ul>
							<li>data transformations</li>
							<li>use meaningful types</li>
							<li>reduce scope of nasty bits</li>
							<li>improve modularity, reuseablility, testability</li>
							<li>local reasoning</li>
						</ul>
					</p>
				</section>
				<section>
					<h2>Workshop goal</h2>
					<p>We will implement the Validation concept.</p>
					<p>This term can be used for different things, even within functional programming. Let's find out what it means for us.</p>
				</section>
				<section>
					<h3>Something might be nil!</h3>
					<pre><code data-trim class="language-ruby">
result = SomeThing.find(42)

if result
  do_something_with(result)
end
					</code></pre>
				</section>
				<section>
					<h3>Something might be nil!</h3>
					<p>Slightly nicer:</p>
					<pre><code data-trim class="language-ruby">
result = SomeThing.find(42)

result.if_not_nil { |r| do_something_with(r) }

# result is optional
					</code></pre>
				</section>
				<section>
					<h3>Something might fail!</h3>
					<p>Why might it be nil? Perhaps something can break.</p>
					<pre><code data-trim class="language-ruby">
begin
  result = SomeThing.find_dangerously(42)
  do_something_with(result)
rescue =&gt; error
  handle_error(error)
end
					</code></pre>
				</section>
				<section>
					<h3>Something might fail!</h3>
					<p>Slightly nicer:</p>
					<pre><code data-trim class="language-ruby">
result = SomeThing.find_dangerously(42)

result.if_not_error { |r| do_something_with(r) }
result.if_error { |e| handle_error(e) }

# result is either success value or error
					</code></pre>
				</section>
				<section>
					<h3>But, what if multiple things might fail?</h3>
					<p>The remote agent or the service might throw an exception, for several hosts.</p>
					<pre><code data-trim class="language-ruby">hosts = ["host1", "host2", "host3"]
results = []; errors = []

hosts.each do |host|
  begin
    first_result = remote_agent.lookup_something_on_host(host)
    second_result = service.use_something(first_result)
    results &lt;&lt; second_result
  rescue RemoteError, ServiceError =&gt; error
    errors &lt;&lt; error
  end
end

do_some_other_things(results) unless errors</code></pre>
				</section>
				<section>
					<h3>Validation generalises this logic</h3>
					<p>It might look something like this:</p>
					<pre><code data-trim class="language-ruby">
hosts = ["host1", "host2", "host3"]

first_results = Validation.map_inputs(hosts, { |host| remote_agent.lookup_something_on_host(host) })
second_results = Validation.flat_map_inputs(first_results, { |thing| service.use_something(thing) })

final_result = Validation.sequence(second_results)
final_result.if_success { |result_list| do_some_other_things(result_list) }
final_result.if_failure { |all_errors| handle_errors(all_errors) }

# final_result is either all success values or all errors (aka Validation)
					</code></pre>
                                        <p style="font-size: 60%;">which is not much better for readability - but it avoids mutation and branching, and encodes the required structure in a class</p>

				</section>
				<section>
					<h3>Sum Types</h3>
					<h4>aka disjoint unions</h4>
					<p>Optional, Either and Validation are all examples of sum types.</p>
					<p>A sum type is a data type with several mutually exclusive representations:</p>
					<ul>
						<li>Optional: Value is present or absent</li>
						<li>Either: Value is of one type or the other</li>
						<li>Validation: Either a list of error values, or a single success value</li>
					</ul>
				</section>
				<section>
					<h2>To the code!</h2>
					<ul>
						<li>we'll implement Validation in pairs or small groups.</li>
						<li>swap who is typing every 5-10 minutes</li>
						<li>take advice from the whole group</li>
						<li>the primary goal is to get the tests passing</li>
						<li>pause often to ensure the entire group understands what has been done so far</li>
					</ul>
				</section>
				<section>
					<h2>Have fun!</h2>
					<p>http://github.com/benhyland/ruby-validation</p>
				</section>
			</div>
		</div>
        
		<script src="lib/js/head.min.js"></script>
		<script src="lib/js/prism.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>
			Reveal.initialize({
				controls: false,
				progress: true,
				history: true,
				center: true,
				
				width: 1200,

				theme: 'simple',
				transition: 'none',
			});
		</script>
	</body>
</html>
